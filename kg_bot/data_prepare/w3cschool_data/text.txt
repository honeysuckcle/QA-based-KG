软件测试是通过考虑软件的所有属性(可靠性，可伸缩性，可移植性，可重用性，可用性)和评估软件组件的执行来查找软件错误或缺陷来识别软件正确性的过程。

软件测试提供了软件的独立视图和目标，并确保软件的适用性。它涉及在所需服务下测试所有组件，以确认它是否满足指定的要求。该过程还向客户提供有关软件质量的信息。

测试是强制性的，因为如果软件由于缺乏测试而导致任何时间失败将是一种危险的情况。因此，没有测试软件就无法部署到最终用户。


测试是一组用于在预定义脚本下确定应用程序正确性的技术，但是，测试无法找到应用程序的所有缺陷。测试的主要目的是检测应用程序的故障，以便发现和纠正故障。它并未证明产品在所有条件下都能正常运行，但仅表明它在某些特定条件下无法正常工作。

测试提供了比较软件的行为和状态与机制的比较，因为该机制可以识别问题。该机制可以包括相同指定产品的过去版本，可比较产品，以及预期目的，相关标准或其他标准的界面，但不限于这些。

测试包括检查代码以及各种环境中的代码执行，条件以及代码的所有检查方面。在当前的软件开发方案中，测试团队可能与开发团队分开，以便从测试中获得的信息可用于纠正软件开发过程

软件是否成功取决于对目标受众的接受，简单的图形用户界面，强大的功能负载测试等。例如，银行业务的受众与视频游戏的受众完全不同。因此，当企业在开发软件产品时，它可以评估软件产品是否对其购买者和其他受众有益。软件开发生命周期(SDLC)是一个创建软件开发结构的过程。SDLC中有不同的阶段，每个阶段都有自己不同的活动。它使开发团队能够设计，创建和交付高质量的产品。
SDLC描述了软件开发的各个阶段和阶段的执行顺序。每个阶段都需要在软件开发的生命周期中从前一阶段交付。需求转化为设计，设计转化为开发和开发成测试，经过测试后提供给客户。
软件开发周期的不同阶段如下所示：

1. 需求阶段

这是开发团队和项目经理的软件开发生命周期中最关键的阶段。在此阶段，客户说明要求，规格，期望以及与产品或软件相关的任何其他特殊要求。所有这些都是由业务经理或项目经理或服务提供公司的分析师收集的。
要求包括如何使用产品以及谁将使用产品来确定操作的负载。从此阶段收集的所有信息对于根据客户要求开发产品至关重要。

2. 设计阶段

设计阶段包括根据需求阶段对新软件的详细分析。这是系统开发生命周期中的高优先级阶段，因为系统的逻辑设计转换为物理设计。需求阶段的输出是所需事物的集合，设计阶段为实现这些需求提供了方法。所有必需的基本工具的决定，如Java，.NET，PHP等编程语言; 数据库，如Oracle，MySQL，硬件和软件的组合，提供了一个平台，软件可以在这个平台上运行而没有任何问题。
有几种技术和工具，如数据流图，流程图，决策表和决策树，数据字典和结构化字典用于描述系统设计。

3. 建设/发展阶段

在成功完成需求和设计阶段之后，下一步是将设计实现到软件系统的开发中。在这个阶段，工作分成小单元，编码由开发团队根据前一阶段讨论的设计开始，并根据需求阶段讨论的客户要求产生所需的结果。
前端开发人员开发简单且有吸引力的GUI和必要的接口，以便与后端操作进行交互，后端开发人员根据所需的操作进行后端编码。所有这些都是根据项目经理演示的程序和指南完成的。
由于这是编码阶段，因此在软件开发生命周期中，开发人员需要花费最长时间和更集中的方法。

4. 测试阶段

测试是完成软件系统的最后一步。在此阶段，在获得开发的GUI和后端组合之后，将根据需求阶段中的要求对其进行测试。测试确定软件是否实际按照需求阶段中的要求提供结果。开发团队制定测试计划以开始测试。该测试计划包括所有类型的基本测试，例如集成测试，单元测试，验收测试和系统测试。在此阶段也进行了非功能性测试。
如果软件中存在任何缺陷，或者它没有按预期工作，那么测试团队会向开发团队提供有关该问题的详细信息。如果它是一个有效的缺陷或值得理清，它将被修复，开发团队将其替换为新的，并且还需要进行验证。

5. 部署/交付阶段

当软件测试完成且结果令人满意，并且软件工作中没有余留问题时，就可以将它交付给客户供其使用。当客户收到产品，建议他们首先进行beta测试。在beta测试中，客户可以要求软件中没有但在需求文档或任何其他GUI更改中提及的任何更改，以使其更加用户友好。除此之外，如果客户使用该软件时遇到任何类型的缺陷; 它将通知该特定软件的开发团队以解决问题。如果这是一个严重的问题，那么开发团队会在短时间内解决它，否则，如果它不那么严重，那么它将等待下一个版本。
在解决了所有类型的错误和变更后，软件最终部署到最终用户。

6. 维护阶段

维护阶段是SDLC的最后和持久阶段，因为它是一直持续到软件生命周期结束的过程。当客户开始使用软件时，实际问题就开始发生，那时需要解决这些问题。此阶段还包括对硬件和软件进行更改以维持其运营效率，例如：提高其性能，增强安全功能以及根据客户的要求和即将到来的时间。这个不时处理产品的过程称为维护。

“因此，所有这些都是软件开发生命周期(SDLC)的六个阶段，在这个阶段，软件开发过程发生。所有这些都是强制阶段，没有任何一个开发是不可能的，因为开发在软件的生命周期中持续进行维护”。软件测试的过程也称为STLC(软件测试生命周期)，其中包括测试过程的各个阶段。测试过程以精心策划和系统的方式执行。所有活动都是为了提高软件产品的质量。
下面来看看STLC的不同阶段。
软件测试生命周期包含以下阶段：

1. 需求分析
手动测试程序的第一步是需求分析。在此阶段，测试人员分析SDLC(软件开发生命周期)的需求文档，以检查客户所述的要求。在检查要求后，测试人员制定测试计划以检查软件是否满足要求。


进入条件 - 对于测试计划需求规范的规划，应该提供应用程序体系结构文档和明确定义的验收标准。



活动行为 - 准备所有要求和查询的列表，并从技术经理/主管，系统架构，业务分析师和客户处获得解决。列出要执行的所有类型的测试(性能，功能和安全性)。列出测试环境详细信息，其中应包含执行测试用例的所有必要工具。



交付成果 - 列出可测试要求和测试环境详细信息的所有必要测试。


2. 测试计划

创建测试计划的创建是STLC的关键阶段，它定义了所有测试策略。测试人员确定整个项目的估计工作量和成本。此阶段在成功完成需求分析阶段后进行。此阶段提供的测试策略和工作量估算文档。成功完成测试计划创建后，可以开始测试用例执行。


进入条件 - 需求文档活动行为 - 定义目标以及软件的范围。列出测试中涉及的方法。测试过程概述。



测试环境的解决。准备测试计划和控制程序。角色和责任的确定。列出测试可交付成果，定义风险(如果有)。



交付成果 - 测试策略文档。测试估算文件是此阶段的交付成果。



3. 环境设置

测试环境的设置是一项独立的活动，可以与测试用例开发一起启动。这是手动测试程序的重要部分，因为没有环境测试无法进行。环境设置需要一组必要的软件和硬件来创建测试环境。测试团队不参与设置测试环境，而是创建测试环境的高级开发人员完成。



进入条件 - 测试策略和测试计划文档。测试用例文档。测试数据。



活动行为 - 通过分析需求规范来准备软件和硬件列表。在设置测试环境之后，执行测试用例以检查测试环境的准备情况。



交付成果 - 执行报告。缺陷报告。


4. 测试用例

执行测试用例在成功完成测试计划后执行。在此阶段，测试团队启动案例开发和执行活动。测试团队记下详细的测试用例，并在需要时准备测试数据。准备好的测试用例由团队的同行成员或质量保证负责人进行审核。
RTM(需求可追溯性矩阵)也在此阶段准备。需求可跟踪性矩阵是行业级格式，用于跟踪需求。每个测试用例都与需求规范一起映射。可以通过RTM完成向后和向前可追溯性。


进入条件 - 需求文档。



活动行为 - 创建测试用例。执行测试用例。根据要求绘制测试用例。



交付成果 - 测试执行结果。具有缺陷详细说明的功能列表。



5. 缺陷记录

测试人员和开发人员根据测试覆盖范围，质量，时间消耗，成本和关键业务目标评估软件的完成标准。此阶段确定了软件的特性和缺点。深入分析测试用例和错误报告，以检测缺陷的类型及其严重性。
缺陷记录分析主要用于根据严重程度和类型找出缺陷分布。如果检测到任何缺陷，则将软件返回给开发团队以修复缺陷，然后在测试的所有方面对软件进行重新测试。
一旦测试周期完全完成，然后测试关闭报告，并准备测试指标。


进入条件 - 测试用例执行报告。缺陷报告



活动行为 - 它根据测试覆盖率，质量，时间消耗，成本和关键业务目标评估软件的完成标准。缺陷记录分析通过对类型和严重性进行分类来找出缺陷分布。



交付成果 - 关闭报告，测试指标


6. 测试周期

关闭测试周期结束报告包括与软件设计，开发，测试结果和缺陷报告相关的所有文档。如果存在具有相同规范的软件，此阶段将评估开发策略，测试过程，可能的缺陷，以便将来使用这些实践。


进入条件 - 所有与软件相关的文档和报告。



活动行为 - 如果存在具有相同规范的软件，则评估开发策略，测试过程，将来可能存在的缺陷以使用这些实践。



交付成果 - 测试结束报告。
软件质量保证(也称为QA)是一系列任务，用于防止缺陷并确保为特定应用程序设计的技术，方法，方法和过程必须正确实施。这是软件系统开发过程中的持续过程。
应用程序单元的开发按照其开发顺序在质量保证规范下进行检查。
质量保证测试确保了高质量软件的开发，因为它主要关注软件开发过程中的高质量流程，良好的质量管理体系和定期的一致性审核。它是一种管理工具，包括计划和系统的活动和文件，以防止与质量有关的问题。

软件质量保证的责任不是任何特定的团队，而是开发团队的每个成员的责任。


软件质量保证可防止缺陷。
软件质量保证是面向过程的。
软件质量保证在流程和预防性方面具有前瞻性。
软件质量保证是一种管理工具。
每个开发人员都负责软件质量保证。


软件质量控制

软件质量控制也称为质量控制，是一系列任务，通过识别缺陷和纠正开发软件中的缺陷来确保软件质量。这是一个被动的过程，此过程的主要目的是在发布软件之前纠正所有类型的缺陷。通过纠正工具消除问题根源(导致质量低下)，从而使软件能够满足客户的要求和高质量，从而完成该过程。

质量控制的责任在于一个特定的团队，称为测试团队，通过验证和纠正工具测试软件的缺陷。


质量控制提供缺陷识别。
质量控制是以产品为导向。
质量控制是一种纠正工具。
测试团队负责质量控制。
质量控制是一个反应过程。


质量保证与质量控制的区别

软件质量保证与质量控制的区别如下表所示 - 





项目
质量保证
质量控制




定义
质量保证是一组活动，可确保始终保持软件开发过程中使用的过程质量。
QC是一组用于检测已开发软件中的缺陷的活动。


关注重点
QA的重点是通过关注流程来防止开发软件中的缺陷。
QC的重点是通过关注测试过程来识别开发软件中的缺陷。


如何做
建立高质量的管理系统，并定期审核开发软件的操作是否符合要求。
通过使用开发软件中的测试技术和工具来检测和消除质量问题元素。


为什么做
质量保证通过使用包括文档在内的系统活动来确保质量问题的预防。
QC通过使用流程和技术来实现和维护高质量的软件，从而确保识别和消除缺陷。


面向
质量保证是面向流程的。
QC是面向产品的。


过程类型
质量保证是一个积极主动的过程。
QC是一种反应过程，因为它涉及在产品开发之后和产品发布之前识别缺陷。


责任
开发团队的每个成员都负责QA
只有特定的测试团队负责QC


示例
验证软件流程。
检验软件功能和流程。


黑盒测试是一种软件测试技术，它可以检查软件的功能，而不会窥视其内部结构或编码。黑盒测试的主要来源是客户声明的要求规范。

在此方法中，测试人员选择一个函数并提供输入值以检查它的功能，并检查该函数是否给出了预期的输出。如果函数产生正确的输出，则在测试中传递，否则测试失败。测试团队将结果报告给开发团队，然后测试下一个功能。如果出现严重问题，在完成所有功能的测试后，会将测试结果返回给开发团队进行更正。




黑盒测试基于要求的规范，因此在开始时进行检查。
测试人员通过选择有效和无效的输入值来检查软件是正确还是错误地处理它们，从而创建肯定的测试场景和不利的测试场景。
测试人员开发各种测试用例，如决策表，所有对测试，等效划分，误差估计，因果图等。
包括执行所有测试用例。
测试仪将预期输出与实际输出进行比较。
最后一步，如果软件中存在任何缺陷，则将其修复并再次测试。


测试程序

黑盒测试的测试过程是测试人员对软件工作有特定知识的一种过程，它开发测试用例以检查软件功能的准确性。

它不需要软件的编程知识。所有测试用例都是通过考虑特定函数的输入和输出来设计的。测试人员知道特定输入的确定输出，但不知道结果是如何产生的。黑盒测试中使用各种技术进行测试，如决策表技术，边界值分析技术，状态转换，全对测试，因果图技术，等价划分技术，错误猜测技术，用例技术和用户故事技术。所有这些技术都已在本教程中详细解释。

测试用例
测试用例是根据要求的规范创建的。这些测试用例通常是根据软件的工作描述创建的，包括要求，设计参数和其他规范。对于测试，测试设计者通过采用有效输入值和不利测试场景来选择正测试场景，方法是采用无效输入值来确定正确的输出。测试用例主要用于功能测试，但也可用于非功能测试。测试用例是由测试团队设计的，没有任何软件开发团队的参与。

黑盒测试使用的技术

以下是黑盒测试使用的技术 - 





编号
技术
描述说明




1
决策表技术
决策表技术是一种系统方法，以表形式捕获各种输入组合及其各自的系统行为。它适用于在两个和两个以上输入之间具有逻辑关系的函数。


2
边界值问题技术
边界值技术用于测试边界值，边界值是包含变量上限和下限的边界值。它在输入边界值时测试软件是否产生正确的输出。


3
状态转换技术
状态转换技术用于在向同一功能提供不同的输入值时捕获软件应用程序的行为。它适用于那些提供访问应用程序的特定尝试次数的应用程序类型。


4
成对测试技术
成对测试技术用于测试所有可能的离散值组合。这种组合方法用于测试使用复选框输入，单选按钮输入，列表框，文本框等的应用程序。


5
因果技术
因果技术强调了给定结果与影响结果的所有因素之间的关系。它基于一系列要求。


6
等价类划分技术
等价类划分是一种软件测试技术，其输入数据被划分为有效值和无效值的分区，并且所有分区必须表现出相同的行为。


7
错误猜测技术
错误猜测是一种没有用于识别错误的特定方法的技术。它基于测试分析师的经验，测试人员使用该经验来猜测软件的有问题区域。


8
用例技术
用例技术用于根据系统的使用情况从系统的开头到结尾识别测试用例。通过使用这种技术，测试团队创建了一个测试场景，可以从头到尾根据每个功能的功能运行整个软件。


决策表技术是用于黑盒测试的广泛使用的用例设计技术之一。这是一种系统方法，它以表格形式捕获各种输入组合及其各自的系统行为。

它也称为因果表。该技术用于系统地选择测试用例; 它节省了测试时间，并为软件应用程序的测试区域提供了良好的覆盖。

决策表技术适用于在两个和两个以上输入之间具有逻辑关系的函数。

该技术与输入的正确组合有关，并确定各种输入组合的结果。要通过决策表技术设计测试用例，需要将条件视为输入，将操作视为输出。

下面通过一个例子来理解它：

大多数人都使用电子邮件帐户，当使用电子邮件帐户时，需要输入电子邮件及其相关密码。

如果电子邮件和密码都正确匹配，则将用户定向到电子邮件帐户的主页; 否则，它将返回登录页面，并显示错误消息“电子邮件不正确”或“密码不正确”。

现在，看看如何为登录功能创建决策表，可以使用电子邮件和密码登录。电子邮件和密码都是条件，预期结果是操作。

在表中，有四个条件或测试用例来测试登录功能。在第一个条件下，如果电子邮件和密码都正确，则应将用户定向到帐户的主页。

在第二种情况下，如果电子邮件正确，但密码不正确，则该功能应显示“密码不正确”。在第三种情况下，如果电子邮件不正确，但密码正确，则应显示“电子邮件不正确”。

现在，在第四个也是最后一个条件下，电子邮件和密码都不正确，那么应显示错误的电子邮件账号。

在此示例中，已包含所有可能的条件或测试用例，并且以相同的方式，测试团队还包括所有可能的测试用例，以便可以在测试级别上修复即将发生的错误。

为了找到所有可能条件的数量，测试者使用2^n公式，其中n表示输入的数量; 在该示例中，输入的数量是2(一个是真，第二个是假)。

可能条件数= 2^第二个条件的值数可能的条件数= 2 ^ 2 = 4

在使用决策表技术时，测试人员确定预期输出，如果函数产生预期输出，则在测试中传递，如果不是，则失败。将失败的软件发送回开发团队以修复缺陷。边界值分析是广泛使用的黑盒测试用例设计技术之一。它用于测试边界值，因为边界附近的输入值具有较高的误差机会。

每当我们通过边界值分析进行测试时，测试人员会在输入边界值时关注软件是否产生正确的输出。

边界值是包含变量上限和下限的值。假设age是任何函数的变量，其最小值为18，最大值为30，18和30都将被视为边界值。

边界值分析的基本假设是，使用边界值创建的测试用例最有可能导致错误。

18和30是边界值，所以测试人员更关注这些值，但这并不说就忽略了像19,20,21,27,29这样的中间值。为该范围的每个值开发测试用例。

边界值的测试是通过制作有效和无效的分区来完成的。测试无效分区是因为在不利条件下测试输出也是必要的。

让我们通过实践来理解：

想象一下，有一个函数接受18到30之间的数字，其中18是最小值，30是有效分区的最大值，该分区的其他值是：19,20,21,22,...,30。无效分区由小于18的数字组成，如：12,14,15,16和17以及31,32,34,36等。为有效和无效分区开发测试用例，以捕获系统在不同输入条件下的行为。

如果软件系统接受有效数字并提供所需的输出，则软件系统将在测试中传递，如果不是，则不成功。在另一种情况下，软件系统不应接受无效数字，如果输入的数字无效，则应显示错误信息。
如果正在测试的软件遵循所有测试指南和规范，则将其发送给发布团队，否则发送给开发团队以修复缺陷。状态转换的一般含义是，相同情况的不同形式，并且根据含义，状态转换方法也是如此。当不同的输入值赋予相同的函数时，它用于捕获软件应用程序的行为。
我们都使用过自动取款机，当从中取款时，它会显示帐户详细信息。现在再次进行另一次交易，然后再次显示帐户详细信息，但第二次交易后显示的详细信息与第一次交易不同，但两个详细信息都使用ATM的相同功能显示。所以这里使用了相同的函数，但每次输出不同时，这称为状态转换。在测试软件应用程序的情况下，此方法测试函数是否遵循进入不同输入的状态转换规范。
这适用于那些提供访问应用程序的特定尝试次数的应用程序类型，例如：在指定次数的错误尝试后会锁定应用程序的登录功能。在使用电子邮件和密码的登录功能中，它提供了特定次数的尝试来访问应用程序，在超过最大尝试次数后，它会锁定然后显示错误消息。

应用程序的登录功能提供最多三次尝试，并且在超过三次尝试之后，它将定向到错误页面。



状态转移表




状态
登录
验证
重定向




S1
第一次尝试
无效
S2


S2
第二次尝试
无效
S3


S3
第三次尝试
无效


S4
主页




S5
错误页面





 

在上述状态转换表中，状态S1表示首次登录尝试。当第一次尝试无效时，将指示用户进行第二次尝试(状态S2)。如果第二次尝试也无效，则用户将被引导到第三次尝试(状态S3)。如果第三次和最后一次尝试无效，则将用户定向到错误页面(状态S5)。
但是如果第三次尝试是有效的，那么它将被引导到主页(状态S4)。
如果第三次尝试有效，如下状态转换表：





状态
登录
验证
重定向




S1
第一次尝试
无效
S2


S2
第二次尝试


无效
S3


S3
第三次尝试
有效


S4
主页




S5
错误页面







通过使用上述状态转换表，可以执行任何软件应用程序的测试。可以通过确定所需的输出来制作状态转换表，然后运行软件系统来检查它是否提供了所需的输出。成对测试技术也称为配对测试。它用于测试所有可能的离散值组合。这种组合方法用于测试使用复选框输入，单选按钮输入的应用程序(当必须选择一个选项时使用单选按钮，例如当选择性别男性或女性时，只能选择一个选项)，列表框 ，文本框等假设有一个用于测试的软件应用程序的功能，其中有10个字段用于输入数据，因此离散组合的总数是10 ^ 10(1000亿)，但是所有组合的测试都很复杂，因为它会花很多时间。下面通过一个例子来理解测试过程：假设有一个包含10个元素的列表框，可以接受1到100个字符的文本框，单选按钮，复选框和确定按钮。输入值在下面给出，可以由给定函数的字段接受。复选框 - 已选中或未选中列表框 -  0,1,2,3,4,5,6,7,8,9，单选按钮 - 开或关文本框 -  1到100之间的字母数。确定按钮 - 不接受任何值，仅重定向到下一页。计算所有可能的组合：Check Box = 2     
List Box = 10     
Radio Button = 2     
Text Box = 100     
Total number of test cases = 2*10*2*100     
                           = 4000
Shell测试用例总数(包括负测试用例)为4000。测试4000个测试用例，是一个非常漫长而耗时的过程。因此，测试团队的任务是减少测试用例的数量，为此，测试团队认为列表框的值是第一个值为0，另一个值可以是任何数字， 现在十个值转换为2个值。复选框和单选按钮的值不能减少，因为每个值只有2个值的组合。最后，文本框的值分为三个输入类别：有效整数，无效整数和alpha特殊字符。现在，我们只有24个测试用例，包括负面测试用例。2*2*2*3 = 24
现在，任务是为所有对技术组合，每列应具有相同数量的值，并且总值应等于24。要使用文本框列，将最常见的输入放在第一个有效整数的位置，在第二个位置放置第二个最常见的输入是无效的整数，并在最后一个位置放置最不常见的输入是一个alpha特殊字符。然后开始填充表格，第一列是一个包含三个值的文本框，下一列是一个包含2个值的列表框，第三列是一个包含2个值的复选框，最后一个列是一个单选按钮有2个值。


文本框
列表框
复选框
单选按钮




有效整数
0
选中
ON


无效整数
其它
未选中
OFF


有效整数
0
选中
ON


无效整数
其它
未选中
OFF


AlphaSpecialCharacter
0
选中
ON


AlphaSpecialCharacter
其它
未选中
OFF


在表中，可以看到传统的软件方法产生的是24个测试用例，而不是4000个案例，而成对测试方法仅在6对测试用例中。因果图来自黑盒测试技术，该技术强调了给定结果与影响结果的所有因素之间的关系。它用于编写动态测试用例。当代码根据用户输入动态运行时，将使用动态测试用例。例如，在使用电子邮件帐户时，在输入有效的电子邮件时，系统会接受它，但是当您输入无效的电子邮件时，它会抛出错误消息。在这种技术中，输入条件被赋予原因，并且这些输入条件的结果具有效果。因果图技术基于一系列需求，用于确定可覆盖软件最大测试区域的最小可能测试用例。因果图测试的主要优点是，它减少了测试执行的时间和成本。该技术旨在减少测试用例的数量，但仍覆盖所有必要的测试用例，覆盖范围最大，以达到所需的应用程序质量。因果图技术通过使用AND，OR和NOT等逻辑运算符将需求规范转换为输入和输出条件之间的逻辑关系。因果图中使用的符号与 -  E1是一种效应，C1和C2是原因。如果C1和C2都为真，那么效果E1将为真。或 - 如果C1和C2中的任何原因为真，那么效果E1将为真。非  - 如果原因C1为假，则效果E1为真。互斥 - 只有一个原因是真的。让我们尝试用一些例子来理解这种技术：情况：第1列中的字符应为A或B，第2列中的字符应为数字。如果两列都包含适当的值，则进行更新。如果第1列的输入不正确，即既不是A也不是B，则将显示消息X。如果第2列中的输入不正确，即输入不是数字，则将显示消息Y。如果第一列中的字符是“A”或“B”，则必须更新文件，而在第二列中，字符应为数字。如果第一列中的值不正确(字符既不是A也不是B)，则会显示消息X。如果第二列中的值不正确(字符不是数字)，则将显示消息Y。现在，将针对上述情况制作因果图：原因：C1  - 第1列中的字符是A。C2  - 第1列中的字符是B。C3  - 第2列中的字符是数字。效果：E1  - 更新(C1或C2)和C3E2  - 显示信息X(不是C1而不是C2)E3  - 显示信息Y(非C3)AND，OR，NOT是逻辑门。效果E1-更新 - 效果E1存在的逻辑是“(C1或C2)和C3”。对于C1或C2，C1和C2中的任何一个都应该为真。对于逻辑AND C3(第2列中的字符应为数字)，C3必须为真。换句话说，对于存在效果E1(更新)，任何一个来自C1和C2，但C3必须为真。可以在图中看到原因C1和C2通过OR逻辑连接，效果E1与AND逻辑连接。效果E2-显示信息X  - 效果E2存在的逻辑是“非C1而不是C2”，这意味着C1(第1列中的字符应为A)和C2(第1列中的字符应为B)应为假。换句话说，对于效果E2的存在，第1列中的字符不应该是A或B。可以在图中看到，C1或C2通过NOT逻辑与效果E2连接。效果E3  - 显示按摩Y-效果E3存在的逻辑是“非C3”，表示原因C3(第2列中的字符是数字)应为假。换句话说，对于效果E3的存在，第2列中的字符不应该是数字。可以在图中看到，C3通过NOT逻辑与效果E3连接。因此，它是给定情况的因果图。测试人员需要将原因和结果转换为逻辑语句，然后设计因果图。如果函数根据输入(原因)给出输出(效果)，则认为它是无缺陷的，如果不这样做，则将其发送给开发团队进行更正。步骤总结：画出效果和原因的圆圈。从效果开始，然后选择导致此效果的原因。最后绘制相互排斥的原因(通过一种效应和一种原因直接连接的独占原因)。使用逻辑门绘制动态测试用例。等效分区是一种软件测试技术，其中输入数据被划分为有效值和无效值的分区，并且所有分区必须表现出相同的行为。如果一个分区的条件为真，则另一个等效分区的条件也必须为真，如果一个分区的条件为假，则另一个等效分区的条件也必须为假。等价划分的原则是，测试用例应设计为至少覆盖每个分区一次。每个等效分区的每个值必须表现出与其他分区相同的行为。等效分区源自软件的要求和规范。这种方法的优点是，它有助于减少测试时间，因为从无限到有限的测试用例数量较少。它适用于测试过程的各个层面。例如，假设存在接受特定数量的数字的软件应用程序的功能，该数字不大于和小于该特定数字。例如，将不接受仅包含六位数，少于或多于六位的OTP号，并且应用程序将用户重定向到错误页。OTP数字 = 6位数字
软件应用程序的函数接受10位移动号码。电话号码 = 10位数字
在这两个示例中，可以看到存在两个同等有效和无效分区的分区，在应用有效值时，例如第一个示例中的六位OTP和第二个示例中的10位移动数，两个有效分区表现相同 ，即重定向到下一页。另外两个分区包含无效值，例如：第一个示例中的5个或少于5个，7个或7个以上，以及第二个示例中的9个或少于9个，11个或11个以上的数字，并且在应用这些无效值时， 无效分区的行为相同，即重定向到错误页面。我们可以在示例中看到，每个示例只有三个测试用例，这也是等效分区的原理，它声明此方法旨在减少测试用例的数量。用例是黑盒测试的功能测试，用于根据系统的使用从系统的开始到结束识别测试用例。通过使用这种技术，测试团队创建了一个测试场景，可以从头到尾根据每个功能的功能运行整个软件。在这种情况下，有一个测试人员代表用户逐个使用系统的功能。在这种情况下，有一个演员代表用户使用软件系统的功能。这描述了软件应用程序的逐步功能，可以通过一个例子来理解，假设存在在线资金转移的软件应用程序。转账的各个步骤如下：用户登录以进行实际用户的身份验证。系统检查数据库的ID和密码，以确保它是否是有效用户。如果验证成功，则服务器将用户连接到帐户页面，否则返回登录页面。在帐户页面中，有几个选项，因为审查员正在检查汇款选项; 用户进入汇款选项。在成功完成该步骤之后，用户输入他想要转账的账号。用户还需要输入其他详细信息，如银行名称，金额，IFSC代码，家庭分支等。在最后一步中，如果存在包括验证ATM卡号和PIN的安全功能，则输入ATM卡号，PIN和其他所需详细信息。如果系统成功执行了所有步骤，则无需为此功能设计测试用例。通过描述使用的步骤，可以很容易地为软件系统设计测试用例。作者：
						Maxsu
					Java技术QQ群：227270512 / Linux QQ群：479429477
				








软件测试的盒子测试方法包括黑盒测试和白盒测试。在这里讨论白盒测试，也称为玻璃盒测试，结构测试，开箱测试和透明盒测试。它测试软件的内部编码和基础设施，重点是根据预期和期望的输出检查预定义的输入。它基于应用程序的内部工作方式，并围绕内部结构测试。在这种类型的测试中，编程测试用例需要编程技巧。白盒测试的主要目标是通过软件关注输入和输出流，并加强软件的安全性。
由于系统的内部透视，使用术语“白盒子”。透明框或白框或透明框名称表示能够透过软件的外壳进入其内部工作。
白盒测试的测试用例源自软件开发生命周期的设计阶段。数据流测试，控制流测试，路径测试，分支测试，声明和决策覆盖所有这些技术使用白盒测试作为创建无错误软件的指南。

白盒测试遵循一些工作步骤，使测试易于管理，并且易于理解下一个要完成的任务。执行白盒测试有一些基本步骤。
白盒测试的通用步骤
设计所有测试场景，测试用例并根据高优先级编号对其进行优先级排序。此步骤涉及在运行时研究代码以检查资源利用率，而不是访问代码区域，各种方法和操作所花费的时间等。在此步骤中，将对内部子例程进行测试。内部子例程(如非公共方法，接口)能够适当地处理所有类型的数据。此步骤侧重于测试控制语句(如循环和条件语句)，以检查不同数据输入的效率和准确性。在最后一步中，白盒测试包括安全测试，通过查看代码如何处理安全性来检查所有可能的安全漏洞。
白盒测试的原因
它识别内部安全漏洞。检查代码中的输入方式。检查条件循环的功能。在单个级别测试函数，对象和语句。
白盒测试的优点
白盒测试可以优化代码，从而可以识别隐藏的错误。白盒测试的测试用例可以轻松实现自动化。此测试比其他测试方法更全面，因为它涵盖了所有代码路径。即使没有GUI，它也可以在SDLC阶段启动。
白盒测试的缺点
在大规模编程应用程序中，白盒测试耗费太多时间。白盒测试非常昂贵且复杂。它可能导致生产错误，因为开发人员没有详细说明。白盒测试需要具备编程语言和实现的详细知识和理解的专业程序员。
白盒测试中使用的技术


测试技术
描述




数据流测试
数据流测试是一组测试策略，用于检查程序的控制流程，以便根据事件的顺序探索变量的顺序。


控制流程测试
控制流测试通过控制结构确定语句或程序指令的执行顺序。程序的控制结构用于开发程序的测试用例。在该技术中，测试者选择大程序的特定部分来设置测试路径。测试用例由程序的控制图表示。


分支覆盖测试
分支覆盖技术用于覆盖控制流图的所有分支。它至少涵盖决策点的每个条件的所有可能结果(真实和错误)。


语句覆盖测试
语句覆盖技术用于设计白盒测试用例。该技术涉及至少执行一次源代码的所有语句。它用于计算源代码中执行语句的总数，在源代码中存在的总语句中。



此技术报告布尔表达式的真假结果。每当语句中有两个或多个结果的可能性时，如while语句，if语句和case语句(控制流语句)，这些都视为决策点，因为有两个结果为true或false。数据流测试用于分析程序中的数据流。它是收集有关变量如何在程序中流动数据的过程。它试图获得过程中每个特定点的特定信息。数据流测试是一组测试策略，用于检查程序的控制流程，以便根据事件的顺序探索变量的顺序。它主要关注分配给变量的值和通过集中在两个点上使用这些值的点，可以测试数据流。数据流测试使用控制流图来检测可能中断数据流的不合逻辑的事物。由于以下原因，在值和变量之间的关联时检测到数据流中的异常：如果使用变量而没有初始化。如果初始化变量至少未使用一次。让我们通过一个例子来理解：在这段代码中，总共有8个语句，将选择一个涵盖所有8个语句的路径。正如代码中显而易见的那样，无法覆盖单个路径中的所有语句，因为如果语句2为真，则语句4,5,6,7未被覆盖，如果语句4为真，则语句2和3不包括在内。因此，采取两种方式来涵盖所有陈述。x= 1
Path - 1, 2, 3, 8
Shell输出结果为：2
当首先将x的值设置为1时，它会在步骤1中读取并分配x的值(在路径中取1)然后来到语句2(x> 0(在路径中取2))它是真， 它来自语句3(a = x + 1(在路径中取3))最后它出现在语句8上以打印x的值(输出为2)。对于第二条路径，取x的值为1 -Set x= -1
Path = 1, 2, 4, 5, 6, 5, 6, 5, 7, 8
输出结果为：2
当将x的值设置为1，然后是第一个时，它会在步骤1中读取并分配x的值(在路径中取1)然后来到第2步，它是假的，因为x不大于0 (x> 0，x = -1)。由于错误的条件，它不会出现在语句3上并且直接跳转到语句4(在路径中取4)并且4为真(x <= 0并且它们的x小于0)然后出现在语句5(x < 1(在路径中取5))这也是真的所以它将出现在语句6(x = x + 1(在路径中取6))并且这里x增加1。所以，x=-1+1 
x=0
x的值变为0。现在它转到语句5(x <1(在路径中取5))值为0且0小于1所以，它是真的。声明6(x = x + 1(在路径中取6))。x=x+1 
x= 0+1 
x=1
将x变为1并再次转到语句5(x <1(在路径中取5))现在1不小于1因此，条件为假，它将来到其他部分时语句7(a = x +，其中x的值为1)并将值赋给a(a = 2)。最后，它出现在语句8上并打印出值(输出为2)。为代码建立关联。在关联中，我们列出了所有定义及其所有用途。(1, (2, f), x), (1, (2, t), x), (1, 3, x), (1, (4, t), x), (1, (4, f), x), (1, (5, t), x), (1, (5, f), x), (1, 6, x), (1, 7, x), (6,(5, f)x), (6,(5,t)x), (6, 6, x), (3, 8, a), (7, 8, a)控制流测试是一种白盒测试下的测试技术。该技术的目的是通过控制结构确定语句或程序指令的执行顺序。程序的控制结构用于开发程序的测试用例。在该技术中，测试者选择大程序的特定部分来设置测试路径。它主要用于单元测试。测试用例由程序的控制图表示。控制流图由节点，边缘，决策节点，结节点形成，以指定所有可能的执行路径。用于控制流图的符号节点边缘决策节点连接节点节点控制流程图中的节点用于创建过程路径。它代表了接下来程序的程序顺序，测试人员可以确定程序的发生顺序。我们在下面的示例中可以看到第一个节点表示启动过程，下一个过程是在赋值后分配n的值，如果是18或更大的值，则根据n的值确定过程的下一个节点的决策节点 如果小于18不符合条件的程序执行，那么它是合理的，程序将以其他方式执行。下一个节点是结节点，最后一个节点是停止节点以停止该过程。边缘控制流图中的边用于链接节点的方向。在下面的示例中可以看到，所有箭头都用于在适当的方向上链接节点。决策节点控制流程图中的决策节点用于根据值确定过程的下一个节点。可以在下面的示例中看到决策节点根据n的值确定过程的下一个节点，如果它是18或大于18，那么如果小于18，则合格的过程将执行，否则执行不合格的过程。连接节点控制流图中的结点节点是至少三个链路相遇的点。示例public class VoteEligiblityAge{  

    public static void main(String []args){  
        int n=45;  
        if(n>=18)  
        {  
            System.out.println("你有投票资格。");  
        }else{  
           System.out.println("你没有投票资格。");  
        }  
    }  
}
Java控制流程图上面的例子显示了投票年龄的资格标准，如果年龄是18岁或者超过18岁，那么打印消息“你有投票资格”，如果它少于18，则打印“你没有投票资格”。此方案的程序如上所述，控制流程图是为测试目的而设计的。在控制流图中，start，age，qualified，not eligible和stop是节点，n> = 18是决定哪个部分(if或else)将根据给定值执行的决策节点。符合条件的节点和不符合条件的节点的连接在停止节点上。通过程序的流程图设计测试用例，以确定执行路径是否正确。所有节点，连接点，边缘和决策都是设计测试用例的基本部分。//原文出自【易百教程】，商业转载请联系作者获得授权，非商业转载请保留原文链接：https://www.yiibai.com/software_testing/control-flow-testing-in-white-box-testing.html

分支覆盖技术用于覆盖控制流图的所有分支。它至少涵盖决策点的每个条件的所有可能结果(真和假)。分支覆盖技术是一种白盒测试技术，可确保每个决策点的每个分支都必须执行。然而，分支覆盖技术和决策覆盖技术非常相似，但两者之间存在关键差异。决策覆盖技术涵盖每个决策点的所有分支，而分支测试涵盖代码的每个决策点的所有分支。换句话说，分支覆盖遵循决策点和分支覆盖边缘。许多不同的指标可用于查找分支覆盖范围和决策覆盖范围，但一些最基本的指标是：在程序执行期间查找程序的百分比和执行路径。与决策覆盖一样，它也使用控制流图来计算分支数。如何计算分支覆盖范围？有几种方法可以计算分支覆盖率，但寻路是最常用的方法。在此方法中，执行分支的路径数用于计算分支覆盖范围。分支覆盖技术可用作决策覆盖的替代方案。在某处，它没有被定义为单独的技术，但它不同于决策覆盖，并且是测试控制流图的所有分支所必需的。让我们用一个例子来理解它：Read X  
Read Y  
IF X+Y > 100 THEN  
Print "Large"  
ENDIF  
If X + Y<100 THEN  
Print "Small"  
ENDIF
这是采用两个变量X和Y以及两个条件的基本代码结构。如果第一个条件为真，则打印“Large”，如果为假，则转到下一个条件。如果第二个条件为真，则打印“Small”。控制代码结构的流程图在上图中，描绘了代码的控制流程图。在第一种情况下，通过“Yes”决定，路径为A1-B2-C4-D6-E8，覆盖边数为1,2,4,5,6和8，但边缘3和7未覆盖 在这条路径上。为了覆盖这些边缘，必须遍历“No”决定。在“No”判定的情况下，路径是A1-B3-5-D7，并且覆盖边缘的数量是3和7。因此，通过穿过这两条路径，所有分支都覆盖。Path 1 - A1-B2-C4-D6-E8
Path 2 - A1-B3-5-D7
Branch Coverage (BC) = Number of paths
    =2



用例
覆盖的分支
路径
分支覆盖




Yes
1, 2, 4, 5, 6, 8
A1-B2-C4-D6-E8
2


No
3,7
A1-B3-5-D7
2


语句覆盖是广泛使用的软件测试之一。它来自白盒测试。语句覆盖技术用于设计白盒测试用例。该技术涉及至少执行一次源代码的所有语句。它用于计算源代码中源代码中执行的语句总数。语句覆盖在白盒测试过程中得出测试用例的场景，该过程基于代码的结构。在白盒测试中，测试人员的专注点是内部源代码和流程图或代码流程图的工作。通常，在内部源代码中，有各种各样的元素，如运算符，方法，数组，循环，控制语句，异常处理程序等。根据给程序的输入，执行一些代码语句，有些可能不执行 被执行。语句覆盖技术的目标是覆盖代码中所有可能的执行语句和路径行。下面通过一个例子来理解计算语句覆盖率的过程：在这里，我们采用源代码根据输入值创建两个不同的场景，以检查每个场景的语句覆盖百分比。源代码结构：输入两个值，如a = 0和b = 1。计算出这两个值的总和。如果总和大于0，则打印“这是正结果”。如果总和小于0，则打印“这是负结果”。input (int a, int b)   
{   
    Function to print sum of these integer values (sum = a+b)   
    If (sum>0)   
    {   
        Print ("这是正结果")   
    } else    
    {   
        Print ("这是负结果")   
    }   
}
所以，这是程序的基本结构，这是它将要完成的任务。现在，让我们看一下两种不同的场景，并计算给定源代码的语句覆盖的百分比。场景1：如果a = 5，则b = 4print (int a, int b) {   
    int sum = a+b;   
    if (sum>0) {   
        Print ("这是正结果")   
    } else    
    {   
        Print ("这是负结果")   
    }   
}
在场景1中，可以看到sum的值是9，并且根据条件结果将是“这是正结果”。以黄色突出显示的语句是此方案的已执行语句。要计算第一个场景的语句覆盖率，假设取语句总数为7和执行语句数为5。Total number of statements = 7  
Number of executed statements = 5
Statement coverage = 5/7*100   
= 500/7  
= 71%
类似地，在场景2中，如果：A = -2, B = -7print (int a, int b) {   
int sum = a+b;   
if (sum>0)   
    print ("这是正的结果")   
else   
    print ("这是负的结果")   
}
在场景2中，可以看到sum的值将是-9(小于0)，并且根据条件，结果将是“这是负的结果”。以黄色突出显示的语句是此方案的已执行语句。要计算第一个场景的语句覆盖率，请使用语句总数为7的和已使用语句数为6。Total number of statements = 7 
Number of executed statements = 6
Statement coverage = 6/7*100 <br>  
= 600/7  
= 85%
但是，可以看到两种情况都涵盖了所有语句，我们可以认为整体语句覆盖率是100％。因此，语句覆盖技术涵盖了死代码，未使用的代码和分支。

					//原文出自【易百教程】，商业转载请联系作者获得授权，非商业转载请保留原文链接：https://www.yiibai.com/software_testing/statement-coverage-testing-in-white-box-testing.html

决策覆盖技术属于白盒测试，它为布尔值提供决策覆盖。此技术报告布尔表达式的真/假结果。每当语句中有两个或多个结果的可能性时，如while语句，if语句和case语句(控制流语句)，它被视为决策点，因为有两个结果为true或false。决策覆盖率通过使用控制流图或图表涵盖代码的每个布尔条件的所有可能结果。通常，决策点有两个决策值，一个是true，另一个是false，这就是为什么大多数时候结果总数是2的原因。决策覆盖率的百分比可以通过将行使结果的数量除以结果总数并乘以100来计算出。在这种技术中，很难获得100％的覆盖率，因为有时表达式变得复杂。因此，有几种不同的方法来报告决策覆盖范围。所有这些方法都涵盖了最重要的组合，非常类似于决策覆盖。这些方法的好处是增强了控制流的灵敏度。我们可以找到决策覆盖的数量如下。下面通过一个例子来理解它。考虑应用于决策覆盖技术的代码：Test (int a)    
{   
    If(a>4)   
        a=a*3   
    Print (a)   
}
场景1：a的值是7(a = 7)，那么 - Test (int a=7)   
{ 
    if (a>4)   
        a=a*3   
    print (a)   
}
如果检查条件(a> 4)，则此代码的结果为“True”。当a的值为7时控制流程图如下 - 决策覆盖率的计算：Decision Coverage = ½*100  (Only "True" is exercised)  
                    =100/2  
                    = 50  
Decision Coverage is 50%
场景2：a的值是3(a = 3)Test (int a=3)   
{ 
    if (a>4)   
        a=a*3   
    print (a)   
}
这段代码的结果是:“False”，因为检查条件(a> 4)。决策覆盖率的计算：= ½*100  (仅在 "False" 时执行) 
=100/2   
= 50  
Decision Coverage = 50%
决策覆盖范围的结果表：


测试用例
A的值
输出
决策覆盖范围




1
3
3
50%


2
7
21
50%灰盒(GreyBox)测试是一种软件测试方法，用于部分了解内部工作结构来测试软件应用程序。它是黑盒子和白盒测试的组合，因为它涉及访问内部编码以设计测试用例，因为白盒测试和测试实践在功能级别作为黑盒测试完成。灰盒(GreyBox)测试通常识别属于Web系统的特定于上下文的错误。例如; 在测试时，如果测试人员遇到任何缺陷，那么他会对代码进行更改以解决缺陷，然后再次实时测试。它专注于任何复杂软件系统的所有层，以提高测试覆盖率。它提供了测试表示层和内部编码结构的能力。它主要用于集成测试和渗透测试。为什么选择灰盒测试？选择灰盒测试的原因如下：它提供了白盒测试和黑盒测试的综合优势。它同时包括开发人员和测试人员的输入值，以提高产品的整体质量。它减少了长时间功能和非功能测试的时间消耗。它为开发人员提供了足够的时间来修复产品缺陷。它包括用户观点，而不是设计师或测试者的观点。它深入涉及用户观点的要求检查和规格确定。灰盒测试策略测试人员必须从源代码设计测试用例时没有必要使用灰盒测试。为了执行此测试，可以基于体系结构，算法，内部状态或程序行为的其他高级描述的知识来设计测试用例。它使用所有简单的黑盒测试技术进行功能测试。测试用例生成基于要求并在通过断言方法测试程序之前预设所有条件。执行灰盒测试的一般步骤是：首先，选择并识别来自黑盒和白盒测试输入的输入。第二，确定这些选定投入的预期产出。第三，确定在测试期间穿越的所有主要路径。第四，任务是确定子功能，这些功能是执行深层次测试的主要功能的一部分。第五，任务是确定子功能的输入。第六，任务是确定子功能的预期输出。第七，任务包括执行子功能的测试用例。第八，任务包括验证结果的正确性。灰盒测试设计的测试用例包括安全相关，浏览器相关，GUI相关，操作系统相关和数据库相关测试。灰盒测试技术矩阵测试这种测试技术属于灰盒测试。它定义了特定程序的所有已使用变量。在任何程序中，变量都是值可以在程序内传播的元素。它应该按照要求，否则会降低程序的可读性和软件的速度。矩阵技术是一种通过识别程序中使用的变量来删除未使用和未初始化变量的方法。回归测试回归测试用于验证软件任何部分的修改是否未对软件的任何其他部分造成任何不利或无意的副作用。在确认测试期间，任何缺陷都得到修复，并且该部分软件开始按预期工作，但固定缺陷可能会在软件中的其他位置引入不同的缺陷。因此，回归测试通过测试重新测试风险用例，在防火墙内重新测试，重新测试所有等策略来处理这些类型的缺陷。正交阵列测试或OAT此测试的目的是用最少的测试用例覆盖最大代码。测试用例的设计方式可以覆盖最大代码以及具有较少测试用例的GUI功能。模式测试模式测试适用于通过遵循先前软件的相同模式而开发的这种类型的软件。在这些类型的软件中可能会出现相同类型的缺陷。模式测试确定失败的原因，以便可以在下一个软件中修复它们。通常，灰盒方法中使用自动化软件测试工具来执行测试过程。提供给测试人员的存根和模块驱动程序可以减轻手动代码生成的负担。黑盒测试，白盒测试与灰盒测试的比较和区别如下所示：


编号
黑盒测试
白盒测试
灰盒测试




1
不需要了解内部工作结构(代码)。测试用例只需要GUI(图形用户界面)。
测试需要了解内部工作结构(软件编码)。
部分了解内部工作结构。


2
黑盒测试也称为功能测试，数据驱动测试和封闭盒测试。
白盒测试也称为结构测试，透明盒测试，基于代码的测试和透明测试。
灰盒测试也称为半透明测试，因为测试人员对编码知识有限。


3
测试方法包括试验技术和错误猜测方法，因为测试人员不需要知道软件的内部编码。
通过验证软件中固有的系统边界和数据域来进行白盒测试，因为不缺乏内部编码知识。
如果测试人员具有编码知识，则通过验证软件的数据域和内部系统边界来进行。


4
输入表的测试空间(用于创建测试用例的输入)非常庞大，在所有测试空间中最大。
与黑盒测试相比，输入表的测试空间(用于创建测试用例的输入)较少。
输入表的测试空间(用于创建测试用例的输入)小于黑盒和白盒测试。


5
发现软件的隐藏错误非常困难，因为错误可能是由于黑盒测试未知的内部工作造成的。
发现隐藏错误很简单，因为它可能是由于内部工作，这在白盒测试中得到了深入探索。
很难发现隐藏的错误，可在用户级测试中找到。


6
它不适用于算法测试。
它非常适合并推荐用于算法测试。
它不被考虑用于算法测试。


7
黑盒测试中的时间消耗取决于功能规范的可用性。
由于冗长的代码，白盒测试需要很长时间来设计测试用例。
测试用例设计可以在短时间内完成。


8
测试人员，开发人员和最终用户可以参与测试。
只有测试人员和开发人员才能参与测试; 最终用户不能涉及。
测试人员，开发人员和最终用户可以参与测试。


9
这是所有测试过程中耗时最少的过程。
在所有测试过程中，整个测试过程是最耗时的。
比白盒测试耗时更少。


10
黑盒测试涵盖了抵御病毒攻击的弹性和安全性。
白盒测试不包括针对病毒攻击的弹性和安全性。
灰盒测试不包括针对病毒攻击的弹性和安全性。


11
黑盒测试的基础是外部期望内部行为未知。
灰盒测试的基础是编码，负责内部工作。
基于高级数据库图表和数据流图进行测试。


12
它不像白盒和灰盒测试方法那么详尽。
黑盒和灰盒测试方法之间最为详尽。
部分详尽; 取决于基于编码或基于GUI的测试用例的类型。可视化测试用于通过定义数据来检查软件故障发生的情况，开发人员可以快速识别故障原因，并清楚地表达信息，以便任何其他开发人员可以利用这些信息。可视化测试旨在显示实际问题，而不仅仅是描述它，显着增加理解和清晰度，以便快速解决问题。可视化意味着我们可以看到的。因此，可视化测试需要整个过程的视频录制。它捕获视频格式系统测试时发生的所有事情。测试仪将图片网络摄像头中的图片和来自麦克风的音频评论作为输入值。可视化检测系统可视化检测系统包括用于收集数据和软件的高质量摄像机以及用于分析数据的计算机。摄像机用于在测试过程中捕获对象的图片。这些对象图片通过帧抓取器发送到计算机。计算机具有分析图片并确定对象是否失败或是否通过检查的软件。视频测试系统工作的条件必须得到很好的控制，并且易于维持测试持久性。可视化测试提供了许多优点。它大大提高了通信质量，因为测试人员可以将问题呈现给开发人员，而不是以书面文档形式描述。开发人员具有测试失败所需的所有证据，因此，重点仅在于失败的原因以及如何解决。下面给出了一些显着的优点和缺点：可视化测试的优点可视化测试很便宜，因为信息是以视频形式记录的。因此不需要以任何其他形式复制信息。它节省了资金。可视化测试提供可移植性。如果软件类型相同，测试人员可以向任何其他测试人员提供视频。因此，在系统出现故障的情况下不会丢失数据。可视化测试节省了测试时间，就像测试过程完成并以可视化形式保存一样，因此不需要再次测试软件。开发人员可以通过观看视频来识别缺陷。可视化测试需要最少的特殊技能。可视化测试需要最少的部件准备，因为需要只找到系统故障的原因。可视化测试的缺点：可视化测试仅适用于可见的表面，因此需要布置合适的表面。可视化测试无法检测隐藏的缺陷; 它只能检测到更大的缺陷。要记录清晰可见的视频照明必须很好地实现。仅遵循规则不能模仿人工检查。划痕和裂缝可能会造成误解。如果软件组件存在差异，则无法通过可视化测试对视觉测试提供产品组件变体。总结当使用易于检测的缺陷测试软件并且不允许组件变化时，可使用可视化测试。手动测试是一种软件测试过程，需要手动执行测试用例而不是使用自动化工具。测试人员根据最终用户的角度手动执行所有测试用例。它确保应用程序是否正如需求文档中所述那样工作。计划和实施测试用例以完成几乎100%的软件应用程序。测试用例报告也是手动生成的。手动测试是最基本的测试过程之一，因为它可以找到软件的可见和隐藏缺陷。由软件给出的预期输出和输出之间的差异被定义为缺陷。开发人员修复了缺陷并将其交给测试人员进行重新测试。在自动化测试之前，每个新开发的软件都必须进行手动测试这项测试需要付出很大的努力和时间，但它确保了无错误的软件。手动测试需要手动测试技术的知识，但不需要任何自动测试工具。手动测试至关重要，因为其中一个软件测试基础是“100%自动化是不可能的”。有各种方法可用于手动测试。根据其测试标准使用每种方法。手动测试的类型如下：手动测试的类型黑盒测试白盒测试单元测试系统测试集成测试验收测试如何进行手动测试首先，测试人员检查与软件相关的所有文档，以选择测试区域。测试人员分析需求文档以涵盖客户声明的所有要求。测试人员根据需求文档开发测试用例。通过使用黑盒测试和白盒测试手动执行所有测试用例。如果出现错误，则测试团队会通知开发团队。开发团队修复错误并将软件交给测试团队进行重新测试。手动测试的优点使用黑盒方法时不需要编程知识。它用于测试动态变化的GUI设计。测试人员将软件作为真实用户进行交互，以便他们能够发现可用性和用户界面问题。它确保软件百分百无错误。它具有成本效益。易于学习新测试人员。手动测试的缺点它需要大量的人力资源。这非常耗时。测试人员根据他们的技能和经验开发测试用例。没有证据表明他们已经涵盖了所有功能。测试用例不能再次使用。需要为每个新软件开发单独的测试用例。它不提供测试的所有方面的测试。由于两个团队一起工作，有时很难理解彼此的动机，它可能会误导这个过程。手动测试工具Selenium - Selenium用于测试Web应用程序。Appium - Appium用于测试移动应用程序。TestLink - TestLink用于测试管理。Postman - Postman用于API测试。Firebug - Firebug是一个在线调试器。JMeter - JMeter用于任何应用程序的负载测试。Mantis - Mantis用于跟踪错误。当使用自动化测试工具执行测试用例套件时，称为自动化测试。测试过程通过使用特殊的自动化工具来控制测试用例的执行并将实际结果与预期结果进行比较。自动化测试需要相当大的资源和资金投入。通常，重复动作在自动化测试中进行测试，例如：回归测试。自动化测试中使用的测试工具不仅用于回归测试，还用于自动GUI交互，数据设置生成，缺陷记录和产品安装。自动化测试的目标是减少手动测试用例，但不能消除任何测试用例。可以使用自动化工具记录测试套件，测试人员可以根据要求再次播放这些套件套件。自动化测试套件不需要任何人为干预。自动化测试的生命周期自动化测试的生命周期是一种系统的方法，用于以有限的资源提供最大的测试覆盖率来组织和执行测试活动。测试的结构涉及多步骤过程，该过程支持执行任务所需的，详细的和相互关联的活动。自动化测试的生命周期包括以下组件：1. 决定自动化测试这是自动化测试生命周期方法论(ATLM)的第一阶段。在此阶段，测试团队的主要重点是管理测试的期望，并找出正确应用自动化测试的潜在好处。在采用自动化测试服务时，组织必须面对许多问题，其中一些问题如下：自动化测试需要测试工具专家，所以第一个问题是指定一个测试设备专家。第二个问题是，选择用于测试特定功能的确切工具。设计和开发标准在实施自动化测试过程中的问题。分析各种自动化测试工具，选择最佳的自动化测试工具。金钱和时间的问题发生在测试开始时金钱和时间的消耗很高。2. 测试工具选择测试工具选择代表自动化测试生命周期方法(ATLM)的第二阶段。该阶段指导测试人员评估和选择测试工具。由于测试工具几乎支持所有测试要求，因此测试人员仍需要查看系统工程环境和其他组织需求，然后列出工具的评估参数。测试工程师根据提供的样本标准评估设备。3. 范围介绍此阶段代表自动化测试生命周期方法(ATLM)的第三阶段。自动化范围包括应用程序的测试区域。范围的确定基于以下几点：每个软件应用程序持有的软件应用程序的常用功能。自动化测试设置可重用的业务组件范围。自动化测试决定业务组件的可重用性程度。应用程序应具有特定于业务的功能，并且必须在技术上可行。在跨浏览器测试的情况下，自动化测试提供了重复的测试用例。此阶段确保整体测试策略应在需要时进行妥善管理和修改。为了确保技能的可用性，针对特定软件应用程序所需的特定技能分析特定成员和整个团队的测试技能。4. 测试计划与开发测试计划和开发是自动化测试生命周期方法学(ATLM)的第四个也是最重要的阶段，因为这里定义了所有测试策略。在此阶段确定了长期测试活动的规划，标准和指南的创建，硬件，软件和网络的所需组合的安排，以创建测试环境，缺陷跟踪程序，控制测试配置和环境的指导方针。测试人员确定整个项目的估计工作量和成本。测试策略和工作量估算文档是此阶段提供的可交付成果。成功完成测试计划后，可以开始测试用例执行。5. 测试用例执行测试用例执行是自动化测试生命周期方法论(ATLM)的第六阶段。它在成功完成测试计划后进行。在此阶段，测试团队定义测试设计和开发。现在，测试用例可以在产品测试下执行。在这个阶段，测试团队使用自动化工具启动案例开发和执行活动。准备好的测试用例由测试团队的同行成员或质量保证负责人进行审核。在执行测试程序期间，测试团队指示遵守执行计划。执行阶段实施先前在测试计划中定义的集成，验收和单元测试等策略。6. 审查和评估审查和评估是自动化测试生命周期的第六个也是最后一个阶段，但该阶段的活动在整个生命周期中进行，以保持持续的质量改进。改进过程通过评估矩阵，审查和评估活动来完成。在审查期间，审查员集中讨论特定度量是否满足验收标准，如果是，则可以在软件生产中使用。它是全面的，因为测试用例涵盖了应用程序的每个功能。测试团队进行自己的调查，以询问过程的潜在价值; 如果潜在的好处不够，测试团队可以更改测试工具。该团队还提供样本调查表，以询问最终用户关于软件产品的属性和管理的反馈。自动化测试的优势自动化测试比手动测试花费的时间更少。如果重复执行相同操作多次，则测试者可以测试软件的响应。自动化测试提供了测试用例的可重用性，可用于测试同一软件的不同版本。自动化测试是可靠的，因为它通过以相同方式再次执行测试用例来消除隐藏错误。自动化测试非常全面，因为测试用例涵盖了应用程序的每个功能。它不需要很多人力资源，而是编写测试用例并手动测试，他们需要一个自动化测试工程师来运行它们。自动化测试的成本低于手动测试，因为它需要一些人力资源。自动化测试的缺点自动化测试需要高水平的熟练测试人员。它需要高质量的测试工具。当遇到不成功的测试用例时，整个事件的分析很复杂。测试维护是昂贵的，因为需要高费用许可证测试设备。如果没有解决效率较低的错误，则必须进行调试，这可能会导致致命的结果。系统测试包括测试完全集成的软件系统。通常，计算机系统是通过软件集成制成的。换句话说，一组软件的计算机系统执行各种任务，但只有软件才能执行任务; 软件必须与兼容的硬件接口。系统测试是一系列不同类型的有目的的测试行使和审查针对需求的集成软件的计算机系统的全部工作。软件测试分为四个级别：单元测试，集成测试，系统测试和验收测试，所有这些都用于测试目的。单元测试用于测试单个软件; 集成测试用于测试整个系统系统，系统测试用于测试整个系统，验收测试用于测试业务需求的可接受性。在这里，我们讨论系统测试，这是第三级测试级别。测试级别的层次结构有两种测试软件的方法 - 白盒测试黑盒测试白盒测试它使用内部编码来设计测试用例。黑盒测试下的系统测试，包括测试软件的外部工作。测试遵循用户的观点来识别微小缺陷。系统测试包括以下步骤。验证要测试的应用程序的输入函数。通过外围设备测试集成软件，以检查各个组件之间的相互作用。测试整个系统的端到端测试。通过auser的经验测试应用程序的行为。系统测试的类型系统测试超过50种类型，但软件测试公司使用其中的一些。这些列表如下：回归测试它确保在开发过程中所做的任何更改都失败了保证; 随着时间的推移，新软件的添加不存在旧缺陷。负载测试负载测试正在进行中。检查系统是否可以在实时负载下进行。功能测试测试仪执行应该在系统中的重要功能列表，并且可以在功能测试期间添加，并且应该提高系统的质量。恢复测试恢复测试用于测试系统的可靠性，可信度和责任性的过程中是成功的。迁移测试所以它应该没有任何问题进行修改。可用性测试这样做的目的是确保系统熟悉用户。软件和硬件测试该系统测试旨在检查硬件和软件的兼容性。硬件配置必须与软件兼容。兼容性通过提供硬件和软件提供灵活性。为什么系统测试很重要？系统测试可以100％保证系统性能，因为它涵盖了系统的端到端功能。它包括测试系统软件架构和业务需求。即使在生产之后，它也有助于缓解实时问题和错误。系统测试使用现有系统和新系统将相同数据添加到功能和功能。在从开发团队接收构建软件时，冒烟测试(Smoke Testing)就出现了。测试的目的是确定软件是否可测试。它是在“构建软件”时完成的。该过程也称为“第0天”。这是一个节省时间的过程。它减少了测试时间，因为关键错误不是固定的。冒烟测试的重点是应用程序的核心和主要功能的工作流程。进行冒烟测试的过程冒烟测试不需要设计测试用例。只需要很少的用例。如上所述，关于核心应用程序工作流程的冒烟测试(Smoke Testing)，选择涵盖应用程序主要功能的测试用例套件。测试用例的数量应尽量减少，执行的时间尽可能不要超过半小时。实时示例：假设在电子商务网站上使用，该网站的核心工作应该是登录，特定搜索，将项目添加到购物车，将项目添加到收藏夹，付款选项等。经过测试，测试人员必须对应用程序的运行充满信心。工作流程的步骤如下：点击项目(页面)页面应该是打开的。点击添加到购物车购物车应该打开点击立即购买应显示付款选项。选择其中之一。下单付款如果此功能正常工作，则测试人员希望在测试中通过它，然测试应用程序的下一个功能。在接收开发团队的软件构建(代码中的微小更改)时进行的完整性测试。
理智测试的目的是确保所有缺陷都得到解决。
这是一种回归测试，仅关注一些受影响的功能。
可以在两种情况下进行健全性测试：一种是在第二次增强的情况下，一种是在缺陷固定的情况下。它确保代码或函数中所做的更改不会对相关模块产生影响，因此无法应用。
进行健全性测试的过程
同样，冒烟测试测试人员不需要是一个单独的测试用例进行健全性测试。测试人员只需要测试已设计的测试用例中的修改或缺陷固定功能的情况。修改或有缺陷的功能已经过测试; 测试人员使用他之前完成的相同测试用例。
实时示例：
我们举个例子。获取任何支付网站的功能帐户。测试人员修改并修复了帐户功能中可能发生的一些缺陷。健全测试测试对修改的功能执行测试，即功能是否正常工作。



健全性测试检查修改或缺陷固定功能，它不检查端到端功能。它是回归测试的子集。





冒烟测试与健全测试比较和区别如下表所示：


编号
冒烟测试
健全测试




1
它是一种测试应用程序所有部分测试位置的广泛方法。
它是一种测试应用程序特定部分的狭隘方法。


2
它通过执行严格的测试来测量系统的稳定性。
它通过执行严格的测试来衡量系统的合理性。


3
烟雾测试可以手动或自动进行。
可以在没有测试用例或脚本的情况下完成健全性测试。


4
它由测试人员和开发人员执行。
它仅由测试人员执行。


5
测试是在没有深入的情况下完成的，但是每当需要时，测试人员必须深入研究
完整性测试不需要深入了解应用程序。


6
烟雾测试记录到文档。
完整性测试不用记录到文档。


7
它用于测试应用程序的端到端功能。
它仅用于测试修改或缺陷固定功能。


8
它被视为验收测试的子集。
它被认为是回归测试的一个子集。单元测试涉及测试软件应用程序的每个单元或单个组件。这是第一级软件测试。单元测试的目的是验证单元组件的性能。单元是软件系统的单个可测试部分，并在应用程序软件的开发阶段进行测试。此测试旨在测试隔离代码的正确性。单元组件是应用程序的单独功能或代码。白盒测试方法用于单元测试，通常由开发人员完成。在测试级别层次结构中，单元测试是在集成和其他剩余测试级别之前完成的第一级测试。它使用模块进行测试，减少了等待单元测试框架的依赖性，存根，驱动程序和模拟对象用于单元测试的辅助。单元测试背后的原因通常，软件属于四级测试：单元测试，集成测试，系统测试和验收测试，但有时由于时间消耗，软件测试人员进行的单元测试最少，但单元测试的跳过可能会导致集成测试，系统测试期间出现更高的缺陷 ，以及验收测试，甚至在完成软件应用程序后进行的Beta测试期间。下面列出了一些重要原因：单元测试可帮助测试人员和开发人员理解代码的基础，使它们能够快速更改导致代码的缺陷。单元测试有助于文档。单元测试在开发阶段很早就修复了缺陷，因此在即将到来的测试级别中可能会出现少量缺陷的原因。它通过迁移代码和测试用例来帮助实现代码的可重用性。单元测试技术单元测试使用所有白盒测试技术，因为它使用软件应用程序的代码：数据流测试控制流程测试分支覆盖测试报告覆盖率测试决策覆盖率测试单元测试工具：NUnit：NUnit是一个主要用于.Net语言的单元测试框架。它允许手动编写测试用例脚本并支持数据驱动的测试用例。JUnit：JUnit是一个主要用于java语言的单元测试框架。JUnit提供了用于识别方法的断言。PHPUnit：用于PHP语言的PHPUnit单元测试工具。它提供断言以使用断言方法(方法是预定义的)来确保系统以所需方式运行。Parasoft Jtest：Parasoft Jtest是一个集成的IDE插件Junit，Mockito，PowerMock和Spring，只需轻松一键式活动即可扩展，创建和维护单元测试。EMMA：EMMA是一种用于java语言编码的开源单元测试工具。它分析并报告java语言的代码。如何通过单元测试获得最佳结果？通过遵循下面列出的步骤，单元测试可以提供最佳结果而不会混淆并增加复杂性：测试用例必须是独立的，因为如果需求有任何变化或增强，测试用例不会受到影响。单元测试用例的命名约定必须清晰且一致。在单元测试期间，必须先修复已识别的错误，然后再跳转到SDLC的下一阶段。一次只能测试一个代码。通过编写代码来采用测试用例，如果不这样做，将增加执行路径的数量。如果任何模块的代码有变化，请确保该模块可以使用相应的单元测试。单元测试的优点单元测试使用模块方法，因为任何部件都可以在不等待完成另一部件测试的情况下进行测试。开发团队专注于提供的单元功能以及单元测试套件中的功能应该如何理解单元API。单元测试允许开发人员在几天后重构代码并确保模块仍然正常工作而没有任何缺陷。单元测试的缺点它无法识别集成或广泛级错误，因为它适用于代码单元。在单元测试中，不可能对所有执行路径进行评估，因此单元测试无法捕获程序中的每个错误。最适合与其他测试活动结合使用。集成测试是单元测试后软件测试过程的第二个层次。在此测试中，软件的单元或单个组件在组中进行测试。集成测试级别的重点是在集成组件或单元之间交互时暴露缺陷。单元测试使用模块进行测试，这些模块在集成测试中进行组合和测试。该软件使用许多软件模块开发，这些软件模块由不同的编码器或程序员编码。集成测试的目标是检查所有模块之间通信的正确性。集成测试背后的原因虽然软件应用程序的所有模块已经在单元测试中进行了测试，但由于以下原因仍然存在错误：每个模块由个别软件开发人员设计，其编程逻辑可能与其他模块的开发人员不同; 集成测试对于确定软件模块的工作至关重要。检查软件模块与数据库的交互是否是错误的。在模块开发时可以更改或增强要求。这些新要求可能无法在单元测试级别进行测试，因此集成测试成为强制性要求。软件模块之间的不兼容可能会产生错误。测试硬件与软件的兼容性。如果模块之间的异常处理不充分，则可能会产生错误。集成测试技术测试技术(黑盒测试，白盒测试和灰盒测试)都可用于集成测试; 一些列表如下：黑盒测试状态转换技术决策表技术边界值分析成对测试因果图等价划分错误猜测白盒测试数据流测试控制流程测试分支覆盖测试决策覆盖率测试集成测试方法集成测试有两种基本方法：大爆炸增量下面来了解这些方法。大爆炸法在这种方法中，通过一次集成所有模块来完成测试。它对于小型软件系统来说很方便，如果用于大型软件系统，很难识别缺陷。由于该测试可以在完成所有模块之后完成，因为测试团队执行此过程的时间较少，因此可以轻松错过内部链接接口和高风险关键模块。优点：它适用于小型软件系统。缺点：缺陷的识别很困难。小模块很容易丢失。提供测试的时间非常少。增量方法在增量方法中，模块按升序逐个添加或根据需要添加。所选模块必须与逻辑相关。通常，添加两个或两个以上的模块并进行测试以确定功能的正确性。该过程一直持续到所有模块的成功测试。增量方法通过进一步的方法进行：自上而下自下而上混合测试自顶向下 - 自上而下的测试策略处理使用较低级别模块测试更高级别模块的过程，直到成功完成所有模块的测试。由于首先测试了关键模块，因此可以及早发现并修复主要设计缺陷。优点：缺陷的识别很困难。早期的原型是可能的。缺点：由于存根的数量很多，它变得非常复杂。较低级别的模块测试不充分。首先测试关键模块，以减少缺陷的可能性。自下而上方法 - 自下而上测试策略处理下级模块使用更高级别模块进行测试的过程，直到成功完成所有模块的测试。顶级关键模块最后进行测试，因此可能会导致缺陷。优点：缺陷的识别很容易。不需要等待所有模块的开发，因为它节省了时间。缺点：由于缺陷可能发生，最后对关键模块进行测试。没有早期原型的可能性。混合测试方法 - 在这种方法中，将自上而下和自下而上的方法结合起来进行测试。在此过程中，顶层模块使用低级模块进行测试，低级模块同时使用高级模块进行测试。由于每个模块接口都经过测试，因此发生缺陷的可能性较小。好处：混合方法提供自上而下方法和自下而上方法的功能。它是减少方法的最佳时间。它提供所有模块的完整测试。缺点：当该方法同时在两个方向上进行时，该方法需要更高的浓度水平。复杂的方法。集成测试指南首先，确定测试用例策略，通过该策略可以根据测试数据准备可执行的测试用例。检查应用程序的结构和体系结构，并确定首先测试它们的关键模块。设计测试用例以详细验证每个接口。选择输入数据以执行测试用例。输入数据在测试中起着重要作用。修复缺陷并重新测试。回归测试是测试的过程，如果在任何函数中更改代码不会影响软件应用程序的现有功能。该过程确认旧功能仍然适用于新修改的功能。回归测试仅测试修改的或缺陷的固定功能和部分选择的功能，这些功能可能会因修改而受到不利影响。对已经执行的修改函数执行相同的测试用例。这背后的原因是，当任何软件的新版本发布时，它在旧的测试用例下进行测试，以确保所有旧功能仍然以正确性和相同的方式工作。如果任何功能无法正常工作，则意味着更改或添加新代码会引入新错误。

回归测试背后的原因回归测试的要求是：

由于需求的更改或增强，更改或修改了代码。通过添加新功能来增强软件。缺陷解决或修复。修复缺陷后的性能检查。
如何进行回归测试？回归测试在软件应用程序的维护阶段出现，包括错误更正，增强，删除和优化现有功能。这些变化和修改可能会引入新的错误，这些错误可能导致系统的错误工作。这就是回归测试至关重要的原因。
回归测试通过以下技术进行：

回归测试选择在这种技术中，重新执行选定的测试用例套件，而不是重新执行所有测试用例套件。选定的测试用例套件分为可重复使用的测试案例套件和过时的测试案例套件。可重复使用的测试用例套件用于后续的回归周期，但在后续周期中不使用过时的测试用例套件。
测试用例的优先顺序在此技术中，根据关键和常用以及业务影响功能，测试案例套件的优先级。这种技术有助于减少回归测试用例套件的数量。
重新测试全部在这种回归测试技术中，所有测试用例套件都重新执行，因为它需要耗费大量资源并且成本高昂。
回归测试的测试工具当软件不断改进时，需要进行回归测试。手动执行测试用例会增加时间和成本，因此自动测试是明智的选择。
以下是用于回归测试的工具：
QTPQTP代表Quick Test Professional 。它是一种用于回归和功能测试的自动化测试工具。它使用VBScript进行自动化。
Selenium此工具用于Web应用程序的自动测试。它用于基于浏览器的回归测试。
RFTRFT代表Rational Functional Tester。它用于合理的功能测试。它使用java语言来处理软件系统的自动化测试用例。
回归测试指南
收集已修复或修改的软件应用程序的缺陷列表。根据关键和常用以及业务影响功能选择优先级测试用例。如果需要进行回归测试，请选择剩余的测试用例。使用自动化工具执行回归测试。如果发现任何缺陷，则将其发送给开发团队。功能测试是软件测试的一个分支，旨在验证软件应用程序的功能，而不管功能是否根据需求规范运行。通过给出适当的输入值，确定输出并使用预期输出验证实际输出来测试每个功能。功能测试包括通过GUI(图形用户界面)，API(应用程序接口)，安全性，数据库，客户端应用程序，服务器应用程序和应用程序功能进行测试。黑盒测试方法用于功能测试，其中测试内部逻辑的工作而不窥视内部代码。功能测试的目标功能测试的目标是检查主要入口功能，基本可用功能，屏幕GUI的简单流程以及错误消息的显示，无论用户是否可以轻松地在整个应用程序中导航。功能测试的各个步骤：测试人员确认需求规范。测试人员制定了测试计划。根据功能设计的测试用例在此步骤中完成。制作可追溯性的文档。执行设计的测试用例。进行覆盖率分析以检查应用程序的覆盖测试区域。完成缺陷管理以管理缺陷解决。如何进行功能测试了解功能所需的任务。识别输入值。计算已识别输入值的预期输出。逐个执行所有测试用例。将实际输出与预期输出进行比较。功能测试水平单元测试集成测试用户验收测试烟雾/健全测试功能测试的优点－ 它确保了客户或最终用户的满意度。－ 它确保所有功能都符合他们的要求。－ 它确保了软件应用程序的预期工作性能。－ 它降低了与软件相关的风险。－ 它确保安全性。－ 由于功能测试，可以生产无缺陷的软件应用程序。功能测试的缺点功能测试主要通过需要人力资源的手动测试来完成。功能测试很费时间。功能测试是昂贵的。功能测试需要大量的浓度，因此如果测试仪失去浓度，那么系统中可能存在严重的缺陷。功能测试需要熟练和经验丰富的测试人员。系统测试和验收测试的区别如下表所示：


编号
系统测试
验收测试




1
执行系统测试以测试软件的端到端功能。
执行验收测试以测试软件是否符合规定的要求和用户要求。


2
只有开发人员和测试人员才能执行系统测试。
它可以由测试人员，利益相关者和客户执行。


3
它可以是非功能性和功能性测试。
它只能是功能测试。


4
在系统测试中，可测试整个系统的性能。
在验收测试中，测试系统是否符合要求。


5
系统测试使用由测试团队选择的演示输入值。
验收测试使用用户提供的实际实时输入值。


6
在此测试中，包括完整规范的测试，包括软件和硬件，内存和用户数量。
测试软件是否满足用户的所有需求。


7
系统测试是系统测试和集成测试的组合。
验收测试是alpha测试和beta测试的组合。


8
它在验收测试之前执行。
它在系统测试后执行。


9
系统测试涉及非功能测试下的负载和压力测试。
验收测试涉及功能测试下的边界值分析，等价分配和决策表。


10
系统测试中发现的缺陷认为是固定的。
验收测试中发现的缺陷视为产品故障。Alpha测试是一种软件测试中所使用的释放软件真正的用户或公众之前找到的错误。它在实际场景中提供了性能验证。它是一种验收测试。alpha测试的目标是通过识别和修复以前测试过程中无法发现的错误来纠正软件产品。它是在开发结束时和软件beta测试之前完成的。软件工程师或质量保证人员执行alpha测试。通常，它有两个阶段，在第一阶段，开发人员使用调试器软件或硬件辅助调试器，这有助于非常快速地捕获错误。在alpha测试期间，存在大量错误，缺少功能和崩溃。在第二阶段，质量保证人员通过涉及黑白盒和白盒测试技术进行alpha测试。这是一个额外的测试环境。Alpha测试被设想为可用的在线应用程序，该应用程序不能完整使用，但可以打开以检查性能并获得公众的初步反馈。它可以称为软件应用程序的早期版本或即将发布的版本。如何进行alpha测试Alpha测试在单独的计算机系统上的实验室测试环境中完成。由项目经理和开发人员组成的小组定义了alpha测试的目标，并整合了不断发展的项目的结果。测试组的一些基本步骤如下：检查软件的功能要求和设计规范。根据功能开发测试用例。执行所有测试用例。发现缺陷。修复缺陷。Alpha测试的优点它减少了项目的交付时间。它提供了更全面的测试计划和测试用例。快速释放团队，以便他们可以在另一个项目上工作。它可以更好地了解软件的可靠性和可靠性。反馈很快，因此可以进一步提高软件的质量。Alpha测试的缺点它需要一位熟练掌握白盒和黑盒测试的测试人员。它需要软件工具来快速调试。测试在开发后立即完成，因此必须立即使测试仪可用。Beta测试是验收测试的一部分，旨在通过最终用户验证产品的可用性，功能，可靠性和兼容性。当用户通过提供实际输入值来验证软件时，它会为软件增加价值。它有助于提高软件质量并使其走向成功。此外，有助于确定该软件是否值得在未来版本中进行更多投资。它不是受控活动，因为它发生在用户身边。在将软件交付给客户之前，它视为最终测试。发布用于beta测试的软件称为测试版软件。如何执行Beta测试软件的用户通过向所有可执行功能提供实时输入值来执行beta测试。只有用户才能在所需的质量方面对应用程序进行认证。用户视图被视为测试结果，这些也有助于提高性能和提高质量。Beta测试生命周期Beta测试生命周期从Plan开始，到用作beta测试软件的产品发布时结束。设计，构建，测试，审查也是beta测试生命周期的一部分。计划 - 包括软件规划。设计 - 包括软件设计。构建 - 包括软件的开发。测试 - 包括软件测试。复审 - 包括软件的alpha测试。发布 - 包括推出测试版软件。通常，软件应用程序部署在在线门户网站上，因此许多用户可以使用它并传达他们对应用程序的反馈。Beta测试的优点Beta测试会检测到先前测试过程中可能会遗漏的应用程序流和崩溃等问题。Beta测试使用客户验证方法，可降低产品故障风险。客户反馈有助于提高产品质量。它比其他类似的数据收集方法便宜。Beta测试侧重于客户的满意度。Beta测试的缺点Beta测试不会像正在开发的软件那样深入测试软件的功能。通常，用户不测试不太有用的功能; 它只关注最有用的功能。测试一些没有正确使用软件的用户的反馈，浪费了测试人员的时间和金钱。非功能测试是一种软件测试，用于测试非功能性参数，例如：软件的可靠性，负载测试，性能和责任。非功能测试的主要目的是根据非功能参数测试软件系统的读取速度。在功能测试之前，从未测试过非功能测试的参数。非功能性测试作为功能测试也非常重要，因为它在客户满意度中起着至关重要的作用。例如，非功能性测试将测试有多少人可以同时在任何软件上工作。为什么进行非功能性测试功能和非功能测试对于新开发的软件都是强制性的。功能测试检查内部功能的正确性，而非功能测试检查在外部环境中工作的能力。它为软件安装，设置和执行设定了方法。用于内部研究和开发的测量和度量是在非功能测试下收集和生成的。非功能测试提供了产品行为和使用技术的详细知识。它有助于降低生产风险和软件的相关成本。在非功能测试下测试的参数性能测试性能测试消除了软件性能缓慢和有限的原因。软件的读取速度应尽可能快。对于性能测试，需要定义关于预期速度的结构良好且清晰的规范。否则，测试的结果(成功或失败)将不会很明显。负载测试负载测试涉及测试系统的负载能力。负载能力表示尽可能多的人可以同时在系统上工作。安全测试安全测试用于检测软件应用程序的安全漏洞。测试是通过调查系统架构和攻击者的心态来完成的。通过查找最有可能发生攻击的代码区域来进行测试用例。可移植性测试软件的可移植性测试用于验证系统是否可以在不同的操作系统上运行而不会发生任何错误。当存在相同的操作系统但硬件不同时，测试还要测试软件是否正常工作。问责制测试进行问责测试以检查系统是否正常运行。函数应该提供与其创建相同的结果。如果系统给出预期的输出，它将在测试中传递，否则失败。可靠性测试可靠性测试假定软件系统是否在特定条件下正常运行。系统必须运行特定时间和数量的进程。如果系统在这些指定条件下发生故障，则可靠性测试将失败。效率测试效率测试检查开发软件系统所需的资源数量，以及使用了多少这些资源。它还包括对这三点的测试。必须由软件系统满足客户的要求。软件系统应该达到客户的规格。应该做出足够的努力来开发一个软件系统。非功能测试的优点它提供更高级别的安全性。安全性是一项基本功能，因为系统可以免受网络攻击。它确保了系统的加载能力，以便任意数量的用户可以同时使用它。它提高了系统的性能。测试用例永远不会更改，因此不需要多次编写它们。与其他测试过程相比，总体时间消耗较少。非功能测试的缺点每次更新软件时，都会再次执行非功能测试。由于软件更新，人们必须付费才能重新检查软件; 因此软件变得非常昂贵。测试文档是在测试软件应用程序期间或之前创建的工件的文档。文档反映了流程对客户，个人和组织的重要性。包含所有文档的项目具有较高的成熟度。详尽的文档可以节省组织的时间和财富。为什么需要文档？如果测试或开发团队获得的软件无法正常工作并由其他人开发，那么为了找到错误，团队将首先需要一份文档。如果文档可用，那么团队将通过检查文档快速找出错误原因。但是，如果文件不可用，那么测试人员需要再次进行黑盒子和白盒测试，这将浪费组织的时间和金钱。不仅如此，缺乏文档成为接受的问题。示例以微软的实时为例，微软推出具有适当用户指南和文档的每个产品，这些指南和文档非常具有说明性，逻辑一致且易于理解。这些都是他们成功产品背后的原因。使用文档的好处文档阐明了方法和目标的质量。当客户使用软件应用程序时，它确保内部协调。它确保了任务和性能稳定性的清晰度。它提供有关预防任务的反馈。它为计划周期提供反馈。它为质量管理体系的绩效创造了客观证据。测试计划是描述软件测试领域和活动的详细文档。它概述了测试策略，目标，测试计划，所需资源(人力资源，软件和硬件)，测试评估和测试可交付成果。测试计划是每个软件测试的基础。这是最重要的活动，可确保以适当的顺序提供所有计划活动清单。测试计划是用于将软件测试活动作为定义的过程进行的模板，该过程由测试经理完全监视和控制。测试计划的类型测试计划有三种类型主测试计划阶段测试计划测试特定类型的测试计划主测试计划主测试计划是一种具有多级测试的测试计划。它包括一个完整的测试策略。阶段测试计划阶段测试计划是一种测试计划，可以解决测试策略的任何一个阶段。例如，工具列表，测试用例列表等。具体的测试计划为主要类型的测试设计的具体测试计划，如安全测试，负载测试，性能测试等。换句话说，为非功能测试设计的具体测试计划。如何编写测试计划制定测试计划是测试管理过程中最关键的任务。根据IEEE 829，按照以下七个步骤准备测试计划。首先，分析产品结构和架构。现在设计测试策略。定义所有测试目标。定义测试区域。定义所有可用资源。以适当的方式安排所有活动。确定所有测试交付物。测试计划指南折叠测试计划。避免重叠和冗余。如果认为自己不需要上面已经提到的部分，那么请删除该部分并继续。明确点。例如，当将软件系统指定为测试环境的一部分时，提及软件版本而不是名称。避免冗长的段落。尽可能使用列表和表格。需要时更新计划。请勿使用过时且未使用的文档。测试用例是一组条件，测试人员根据这些条件确定软件应用程序是否按照客户的要求工作。测试用例设计包括前提条件，用例名称，输入条件和预期结果。测试用例是第一级操作，源自测试场景。测试用例提供有关测试策略，测试过程，前提条件和预期输出的详细信息。这些在测试过程中执行，以检查软件应用程序是否正在执行它是否已开发的任务。编写测试用例是一次性尝试，可以在回归测试时使用。测试用例通过将缺陷与测试用例ID相关联来帮助测试人员进行缺陷报告。详细的测试用例文档可以作为测试团队的完全证据保护，因为如果开发人员遗漏了某些内容，那么可以在执行这些完全证明的测试用例时捕获它。通常，没有正式的模板用于编写测试用例，但每个测试用例中都包含以下组件 - 测试用例ID前提条件目的步骤实际结果预期结果假设产品模块产品版本修订记录后置条件测试套件许多测试用例可以从一个测试场景中派生出来，有时候会为单个软件功能编写多个测试用例，这些多个测试用例称为测试套件。示例包含测试用例的表格如下：在此表中，已创建用于登录系统的测试用例。所有：True，False和Result对都被视为测试用例。测试人员为每个特定功能开发这些类型的测试用例，以便测试其功能。可追踪性矩阵是一种表格类型的文档，用于开发软件应用程序以跟踪需求。它可用于向前(从需求到设计或编码)和向后(从编码到需求)跟踪。它也称为需求可追踪性矩阵(RTM)。通常，这就像一个包含表格的工作表文档，但是还有许多用户定义的可追溯性矩阵模板。可追溯性矩阵中的每个要求都与其各自的测试用例相关联，以便可以根据具体要求顺序执行测试。下面给出一个表作为示例，以便可以理解可追溯性矩阵的格式：


业务需求
技术要求
测试用例ID




B1
T12
1


B2
T13
2


B3
T14
3


B4
T15
4


我们可以在表中看到有三列和四行用于表示业务需求，技术要求和测试用例ID。假设任何用户需要注册，而B1是此要求的标识，因此测试人员需要选择B1并且他可以使用T12的代码来开发注册功能。可以使用测试用例ID为1来测试此功能。可追溯性矩阵的目标它有助于跟踪在SDLC的各个阶段开发的文档。它确保软件完全满足客户的要求。它有助于检测任何错误的根本原因。